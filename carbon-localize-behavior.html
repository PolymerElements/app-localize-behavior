<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<script src="../intl-messageformat/dist/intl-messageformat.min.js"></script>

<script>

/**
* `Polymer.CarbonLocalizeBehavior` wraps the [format.js](http://formatjs.io/) library to
* help you internationalize your application. Note that if you're on a browser that
* does not natively support the [Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
* object, you must load the polyfill yourself. An example polyfill can
* be found [here](https://github.com/andyearnshaw/Intl.js/).
*
* Sample use:
*
*     <dom-module id="x-app">
*        <template>
*         <div>{{localize('hello', 'Batman')}}</div>
*        </template>
*        <script>
*           Polymer({
*             is: "x-app",
*
*             behaviors: [
*               Polymer.CarbonLocalizeBehavior
*             ],
*
*             properties: {
*               language: {
*                 value: 'en'
*               },
*               resources: {
*                 value: function() {
*                   return {
*                     'en': { 'hello': 'My name is {name}'. },
*                     'fr': { 'hello': 'Je m'apelle {name}'. }
*                   }
*               }
*             }
*           });
*        &lt;/script>
*     </dom-module>
*
* @polymerBehavior Polymer.CarbonLocalizeBehavior
*/
Polymer.CarbonLocalizeBehavior = {
  /**
   * Singleton cache of requests and localized strings. The localized strings
   * cache is invalidated every time the language, resources or formats change.
   * This is the private implementation of the behaviour; don't interact with
   * it directly.
   */
  __localizationCache: {
    requests: {},
    messages: {}
  },

  /**
   * If the element is using `pathToResources` to load an external resources
   * file, fired when the file has been loaded.
   *
   * @event carbon-resources-loaded
   */

  /**
   * If the element is using `pathToResources` to load an external resources
   * file, fired when the file cannot be loaded due to an error.
   *
   * @event carbon-resources-error
   */

  properties: {
    /**
     * The language used for translation.
     */
    language: {
      type: String
    },

    /**
     * The dictionary of localized messages, for each of the languages that
     * are going to be used. See http://formatjs.io/guides/message-syntax/ for
     * more information on the message syntax.
     *
     * For example, a valid dictionary would be:
     * this.resources = {
     *  'en': { 'greeting': 'Hello!' }, 'fr' : { 'greeting': 'Bonjour!' }
     * }
     */
    resources: {
      type: Object
    },

    /**
     * The path to the dictionary of localized messages. The format is the
     * same as the `resources` array, only saved as an external json file.
     * Note that using a path will populate the `resources` property, and override
     * the previous data.
     */
    pathToResources: {
      type: String
    },

    /**
     * Optional dictionary of user defined formats, as explained here:
     * http://formatjs.io/guides/message-syntax/#custom-formats
     *
     * For example, a valid dictionary of formats would be:
     * this.formats = {
     *    number: { USD: { style: 'currency', currency: 'USD' } }
     * }
     */
    formats: {
      type: Object,
      value: function() { return {} }
    },

    /**
     * Translates a string to the current `language`. Any parameters to the
     * string should be passed in order, as follows:
     * `localize(stringKey, param1Name, param1Value, param2Name, param2Value)`
     */
    localize: {
      computed: '__computeLocalize(language, resources, formats)'
    }
  },

  loadResources: function(path) {
    var request = this.constructor.prototype.__localizationCache.requests[path];

    if (!request) {
      request = document.createElement('iron-ajax');
      this.constructor.prototype.__localizationCache.requests[path] = request;

      request.addEventListener('response', this.__onRequestResponse.bind(this));
      request.addEventListener('error', this.__onRequestError.bind(this));

      request.url = path;
      request.handleAs = 'json';
      request.generateRequest();
    } else {
      // Re-use the already cached resources. If the last response is null,
      // it could be because the request is already in flight, but hasn't completed.
      if (!request.lastResponse) {
        request.addEventListener('response', this.__onRequestResponse.bind(this));
        request.addEventListener('error', this.__onRequestError.bind(this));
      } else {
        this.resources = request.lastResponse;
      }
    }
  },

  /**
   * Returns a computed `localize` method, based on the current `language`.
   */
  __computeLocalize: function(language, resources, formats) {
    // Everytime any of the parameters change, invalidate the strings cache.
    this.constructor.prototype.__localizationCache.messages = {};

    return function() {
      var key = arguments[0];
      if (!key || !resources || !language)
        return;

      // Cache the key/value pairs for the same language, so that we don't
      // do extra work if we're just reusing strings across an application.
      var messageKey = key + resources[language][key];
      var msg = this.constructor.prototype.__localizationCache.messages[messageKey];
      if (!msg) {
        msg = new IntlMessageFormat(resources[language][key], language, formats);
        this.constructor.prototype.__localizationCache.messages[messageKey] = msg;
      }

      var args = {};
      for (var i = 1; i < arguments.length; i+=2) {
        args[arguments[i]] = arguments[i+1];
      }

      return msg.format(args);
    };
  },

  __onRequestResponse: function(event) {
    this.resources = event.target.lastResponse;
    this.fire('carbon-resources-loaded');
  },

  __onRequestError: function(event) {
    this.fire('carbon-resources-error');
  }
}

</script>
